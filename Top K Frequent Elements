PROBLEM STATEMENT:
Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.

SOLUTION:
                                                                      USING PRIORITY QUEUE
                                                                        TIME COMPLEXITY: O(n logn)
                                                                        SPACE COMPLEXITY: O(n)

class Solution {
    //O(n logn)
    public int[] topKFrequent(int[] nums, int k) {

        int[] ans= new int[k];

        HashMap<Integer, Integer> mp= new HashMap<>();

        for(int i=0; i<nums.length; i++){
            mp.put(nums[i], mp.getOrDefault(nums[i],0)+1);
        }

        PriorityQueue<Pair> pq= new PriorityQueue<>(
            (a,b)-> Integer.compare(b.freq, a.freq)
        );
        for(Map.Entry<Integer, Integer> e: mp.entrySet()){
            pq.add(new Pair(e.getValue(),e.getKey()));
        }
        int i=1;
        int ind=0;
        while(i<=k && !pq.isEmpty()){
            ans[ind]= pq.poll().num;
            ind++;
            i++;
        }
        return ans;
    }

}
class Pair{
    int freq;
    int num;
    Pair(int freq, int num){
        this.freq= freq;
        this.num=num;
    }
}

                                                                                        APPROACH 2:
                                                                                          TIME COMPLEXITY: O(N)

class Solution {
    //bucket sort
    public int[] topKFrequent(int[] nums, int k) {

        int[] ans= new int[k];

        HashMap<Integer, Integer> mp= new HashMap<>();

        for(int i=0; i<nums.length; i++){
            mp.put(nums[i], mp.getOrDefault(nums[i],0)+1);
        }

        List<List<Integer>> bucket= new ArrayList<>();

        for(int i=0; i<=nums.length; i++){
            bucket.add(new ArrayList<>());
        }

        for(Map.Entry<Integer, Integer> e: mp.entrySet()){
            int freq= e.getValue();
            int num= e.getKey();
            bucket.get(freq).add(num);
        }
        
        int ind=0;
        int i=nums.length;
        while(ind<k && i>=0){
            if(bucket.get(i).size()>0){
                for(int num: bucket.get(i)){
                    ans[ind]= num;
                    ind++;
                    if(ind==k)  return ans;
                }
            }
            i--;
        }
        

        return ans;
    }

}
