PROBLEM STATEMENT:
You are given a 'ROOT' of a binary search tree of integers. The given BST is also a complete binary tree.

Your task is to convert the given binary search tree into a Min Heap and print the preorder traversal of the updated binary search tree.

Note:

Binary Search Tree is a node-based binary tree data structure that has the following properties:

1. The left subtree of a node contains only nodes with keys lesser than the node’s key.
2. The right subtree of a node contains only nodes with keys greater than the node’s key.
3. The left and right subtree each must also be a binary search tree.

A Binary Heap is a Binary Tree with the following property:

1. It’s a complete tree (all levels are filled except possibly the last level and the last level has all keys as left as possible). This property of Binary Heap makes them suitable to be stored in an array.

A Binary Heap is either Min Heap or Max Heap. In a Min Binary Heap, the key at the root must be minimum among all keys present in Binary Heap. The same property must be recursively true for all nodes in Binary Tree. Max Binary Heap is similar to Min Heap.
For example:

Given:- BST’s ‘ROOT’ = 4 2 6 -1 -1 -1 -1 
Then the min-heap in pre-order fashion would be 2 4 6

SOLUTION:

                                                                                      TIME COMPLEXITY: O(n)
                                                                                      SPACE COMPLEXITY: O(n)

import java.util.* ;
import java.io.*; 
/*************************************************************
    
    Following is the Binary Tree node structure:

    class BinaryTreeNode {

	int data;
	BinaryTreeNode left;
	BinaryTreeNode right;
	
	BinaryTreeNode(int data) {
		this.data = data;
		left = null;
		right = null;
	   }
    }

*************************************************************/

public class Solution {
	
	static int index;
	public static BinaryTreeNode convertBST(BinaryTreeNode root) {
		List<Integer> inorder= new ArrayList<>(); //LNR

		inorderTraversal(root, inorder);

		index=0;

		fillPreorder(root, inorder);

		return root;
		

	}
	public static void inorderTraversal(BinaryTreeNode root, List<Integer> res){
		if(root==null)	return;
		inorderTraversal(root.left, res);
		res.add(root.data);
		inorderTraversal(root.right, res);
	}
	
	public static void fillPreorder(BinaryTreeNode root, List<Integer> inorder){
		if(root==null)	return;

		root.data= inorder.get(index);
		index++;
		fillPreorder(root.left, inorder);
		fillPreorder(root.right, inorder);

	}

}












